### 在 Node.js 的事件循环中，各个阶段是 串行 执行的。

也就是说，事件循环会按顺序依次进入每个阶段，并在该阶段中处理任务队列中的任务（宏任务）。
只有在一个阶段的任务全部处理完毕后，事件循环才会进入下一个阶段。

#### 串行执行的过程

1. 依次进入每个阶段：

事件循环从 timers 阶段开始，依次进入 pending callbacks、idle, prepare、poll、check 和 close callbacks 阶段。
在进入下一个阶段之前，当前阶段的所有任务都会被处理完。

2. 每个阶段处理一个队列：

每个阶段都有自己的任务队列，事件循环会从队列中取出任务并执行。
任务处理完成后，事件循环才会进入下一个阶段的任务队列。

3. 微任务优先：

在每个阶段的任务队列执行完之后（在进入下一个阶段之前），事件循环会检查并执行微任务队列中的任务。微任务（如 process.nextTick 和 Promise 的回调）在每个宏任务结束后立即执行。

##### 串行执行的原因

单线程模型：Node.js 基于单线程模型，事件循环需要按顺序处理各个阶段的任务，以避免竞争条件（race conditions）和资源争夺。

任务的依赖关系：许多任务可能依赖于之前阶段的执行结果，因此必须按照严格的顺序执行。比如，setTimeout 的回调必须在 timers 阶段处理，而 setImmediate 的回调必须在 check 阶段处理。

##### 并行与并发

虽然事件循环是串行执行的，但 Node.js 能够并发处理 I/O 操作。通过底层的线程池（如 libuv），Node.js 可以并发地处理多个 I/O 操作，而这些操作完成后会依次在事件循环的 poll 阶段处理回调。也就是说，I/O 操作的执行可以是并发的，但事件循环中的回调处理仍然是串行的。

##### 总结

各个阶段是串行的：事件循环按顺序进入每个阶段，逐一处理任务队列中的任务。
每个阶段内部也是串行的：每个阶段的任务队列中的任务也是按顺序执行的。
微任务优先：在每个阶段的任务执行完毕后，微任务会被优先处理。
Node.js 的这种串行机制确保了任务的有序执行，避免了并发带来的复杂性。
